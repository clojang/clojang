<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Clojang User's Guide</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/atom-one-dark.css" /><script type="text/javascript" src="highlight/highlight.pack.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with the <a href="https://github.com/clojang/codox-theme">Clojang UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">clojang</span> <span class="project-version">0.6.0</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1  current"><a href="20-mid-level-api.html"><div class="inner"><span>Clojang User's Guide</span></div></a></li><li class="depth-1 "><a href="30-talking-to-servers.html"><div class="inner"><span>Talking to Servers: LFE &amp; Clojure</span></div></a></li><li class="depth-1 "><a href="31-talking-to-servers-erlang.html"><div class="inner"><span>Talking to Servers: Erlang &amp; Clojure</span></div></a></li><li class="depth-1 "><a href="32-talking-to-servers-elixir.html"><div class="inner"><span>Talking to Servers: Elixir &amp; Clojure</span></div></a></li><li class="depth-1 "><a href="40-creating-apps.html"><div class="inner"><span>Apps Tutorial</span></div></a></li><li class="depth-1 "><a href="98-other-resources.html"><div class="inner"><span>Other Resources</span></div></a></li><li class="depth-1 "><a href="99-other-versions.html"><div class="inner"><span>API Docs (All Versions)</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>clojang</span></div></div></li><li class="depth-2 branch"><a href="clojang.caller.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>caller</span></div></a></li><li class="depth-2 branch"><a href="clojang.conn.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>conn</span></div></a></li><li class="depth-2 branch"><a href="clojang.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="clojang.epmd.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>epmd</span></div></a></li><li class="depth-2 branch"><a href="clojang.exceptions.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>exceptions</span></div></a></li><li class="depth-2 branch"><a href="clojang.mbox.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>mbox</span></div></a></li><li class="depth-2 branch"><a href="clojang.msg.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>msg</span></div></a></li><li class="depth-2 branch"><a href="clojang.node.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>node</span></div></a></li><li class="depth-2 branch"><a href="clojang.rpc.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>rpc</span></div></a></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>types</span></div></div></li><li class="depth-3 branch"><a href="clojang.types.constructor.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>constructor</span></div></a></li><li class="depth-3 branch"><a href="clojang.types.converter.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>converter</span></div></a></li><li class="depth-3 branch"><a href="clojang.types.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-3 branch"><a href="clojang.types.predicate.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>predicate</span></div></a></li><li class="depth-3"><a href="clojang.types.records.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>records</span></div></a></li><li class="depth-2"><a href="clojang.util.html"><div class="inner"><span class="tree" style="top: -176px;"><span class="top" style="height: 185px;"></span><span class="bottom"></span></span><span>util</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#clojang-users-guide" name="clojang-users-guide"></a>Clojang User’s Guide</h1>
<p><strong>NOTICE</strong>: This document is an adaptatoin of the <em>jiface User’s Guide</em>, (which, in turn was copied from the <a href="erlang/jinterface_users_guide.html">JInterface User’s Guide</a>); the adaptations include significant changes, due to a much more simplified API (or, perhaps more accurately, a more varied API but with sane defaults provided). Unlike the low-level guide upon which it is based, this one provides information for developers interested in using the Clojang API which is designed to save time and effort without the need of manually translating between Clojure and JInterface’s Erlang data types.</p>
<p>In the following examples, we assume that you have <code>require</code>ed the necessary namespaces and <code>import</code>ed the Java classes needed in a Clojang REPL:</p>
<pre><code class="clj">=&gt; (require '[clojang.conn :as conn]
            '[clojang.core :as clojang :refer [! receive self]]
            '[clojang.mbox :as mbox]
            '[clojang.node :as node])
=&gt; (import '[com.ericsson.otp.erlang OtpErlangDecodeException
                                     OtpErlangExit])
</code></pre>
<h2><a href="#nodes" name="nodes"></a>Nodes</h2>
<p>A node as defined by Erlang/OTP is an instance of the Erlang Runtime System, a virtual machine roughly equivalent to a JVM. Each node has a unique name in the form of an identifier composed partly of the hostname on which the node is running, e.g <code>gurka@sallad.com</code>.</p>
<p>When starting an Erlang VM in distribution mode, a node process is started, one with its own message box and the ability to send and receive messages. JInterface by itself does no such thing when the JVM is started. However, Clojang makes use of a Java agent (written in Clojure) to provide this same facility. As such, a Clojure REPL running Clojang has its own default node and associated message box, just like an Erlang or LFE node:</p>
<pre><code class="clj">=&gt; (node/get-default)
#object[com.ericsson.otp.erlang.OtpNode ...]
</code></pre>
<p>It is recommended that you use the default node created for you by the Clojang agent, in order to reduce overhead and the memory footprint of Clojang applications. However, the API provides the ability to create your own nodes, should you wish to.</p>
<p>To do so, you may either use a short name or a name including the host:</p>
<pre><code class="clj">=&gt; (def gurka (node/new :gurka))
#'user/gurka
=&gt; (def gurka (node/new "gurka@localhost"))
#'user/gurka
</code></pre>
<h2><a href="#mailboxes" name="mailboxes"></a>Mailboxes</h2>
<p>Erlang processes running on an Erlang node are identified by process identifiers (pids) and, optionally, by registered names unique within the node. Each Erlang process has an implicit mailbox that is used to receive messages; the mailbox is identified with the pid of the process.</p>
<p>Clojang provides a similar mechanism with the namespace <a href="clojang/current/clojang.mbox.html">clojang.mbox</a>, a mailbox that can be used to send and receive messages asynchronously. Each <code>OtpMbox</code> is identified with a unique pid and , optionally, a registered name unique within the <a href="erlang/java/com/ericsson/otp/erlang/OtpMbox.html">OtpMbox</a>.</p>
<p>When the Clojang agent creates a default node for use by Clojang in a Java VM, it also creates a default message inbox for that node. This is accessible via the following function call:</p>
<pre><code class="clj">=&gt;(mbox/get-default)
#object[com.ericsson.otp.erlang.OtpMbox ...]
</code></pre>
<p>Applications are free to create mailboxes as necessary. This is done as follows, optionally giving it a registered name:</p>
<pre><code class="clj">user=&gt; (def inbox (mbox/new gurka :echo))
#'user/mbox
</code></pre>
<p>Registered names are usually necessary in order to start communication, since it is impossible to know in advance the pid of a remote process. If a well- known name for one of the processes is chosen in advance and known by all communicating parties within an application, each mailbox can send an initial message to the named mailbox, which then can identify the sender pid.</p>
<h2><a href="#connections" name="connections"></a>Connections</h2>
<p>It is not necessary to explicitly set up communication with a remote node. Simply sending a message to a mailbox on that node will cause the OtpNode to create a connection if one does not already exist. Once the connection is established, subsequent messages to the same node will reuse the same connection.</p>
<p>It is possible to check for the existence of a remote node before attempting to communicate with it. Here we send a ping message to the remote node to see if it is alive and accepting connections. Paste the following function in your REPL:</p>
<pre><code class="clj">(defn print-liveliness [node-name]
  (case (node/ping node-name)
    :pong (println "It's aliiiive!")
    :pang (println "Mate, this node wouldn't go 'voom' if ...")))
</code></pre>
<p>Now let’s use it:</p>
<pre><code class="clj">user=&gt; (print-liveliness :gurka)
It's aliiiive!
nil
user=&gt; (print-liveliness :nohost)
Mate, this node wouldn't go 'voom' if ...
nil
</code></pre>
<p>If the call to <code>(node/ping ...)</code> succeeds, a connection to the remote node has been established. Note that it is not necessary to ping remote nodes before communicating with them, but by using ping you can determine if the remote exists before attempting to communicate with it.</p>
<p>Connections are only permitted by nodes using the same security cookie. The cookie is a short string provided either as an argument when creating <a href="clojang/current/clojang.jinterface.otp.nodes.html#var-NodeObject">node</a> objects, or found in the user’s home directory in the file <code>.erlang.cookie</code>. When a connection attempt is made, the string is used as part of the authentication process. If you are having trouble getting communication to work, use the trace facility (described later in this document) to show the connection establishment. A likely problem is that the cookies are different.</p>
<h2><a href="#sending-and-receiving-messages" name="sending-and-receiving-messages"></a>Sending and Receiving Messages</h2>
<p>Messages sent with this package must be instances of <a href="clojang/current/clojang.jinterface.erlang.object.html">object</a> or one of its subclasses. Message can be sent to processes or pids, either by specifying the pid of the remote, or its registered name and node.</p>
<p>In this example, we create a message containing our own pid so the echo process can reply:</p>
<pre><code class="clj">=&gt; (def msg [(mbox/get-pid inbox) :hello-world])
#'user/msg
=&gt; (! inbox :echo :gurka msg)
:ok
=&gt; (receive inbox)
[#clojang.types.records.Pid{:creation 2, :node "gurka@localhost", :id 1, :serial 0}
 :hello-world]
</code></pre>
<p>You can also send messages from Erlang VMs to your <code>node</code>’s mailbox named <code>"echo"</code>. Before you do that, though, start listening in your Clojure REPL:</p>
<pre><code class="clj">=&gt; (receive inbox)
</code></pre>
<p>Next, start up LFE (Lisp Flavoured Erlang) on the same machine with a short name:</p>
<pre><code class="bash">$ /path/to/bin/lfe -sname lfe
LFE Shell V7.2 (abort with ^G)
(lfe@host)&gt;
</code></pre>
<p>Once you’re in the REPL, you’re ready to send a message:</p>
<pre><code class="cl">(lfe@host)&gt; (! #(echo gurka@host) #(hej!))
#(hej!)
</code></pre>
<p>Looking at the Clojure REPL, you’ll see that your <code>receive</code> call has finished and you now have some data:</p>
<pre><code class="clj">[:hej!]
</code></pre>
<h2><a href="#sending-arbitrary-data" name="sending-arbitrary-data"></a>Sending Arbitrary Data</h2>
<p>This package was originally intended to be used for communicating between Java and Erlang, and for that reason the send and receive methods all use Java representations of Erlang data types.</p>
<p>However it is possible to use the package to communicate with remote processes written in Java as well, and in these cases it may be desirable to send other data types.</p>
<p>The simplest way to do this is to encapsulate arbitrary data in messages of type OtpErlangBinary. The OtpErlangBinary class can be created from arbitrary Java objects that implement the Serializable or Externalizable interface:</p>
<pre><code class="clj">TBD
</code></pre>
<h2><a href="#linking-to-remote-processes" name="linking-to-remote-processes"></a>Linking to Remote Processes</h2>
<p>Erlang defines a concept known as linked processes. A link is an implicit connection between two processes that causes an exception to be raised in one of the processes if the other process terminates for any reason. Links are bidirectional: it does not matter which of the two processes created the link or which of the linked processes eventually terminates; an exception will be raised in the remaining process. Links are also idempotent: at most one link can exist between two given processes, only one operation is necessary to remove the link.</p>
<p><code>clojang</code> provides a similar mechanism. Also here, no distinction is made between mailboxes and Erlang processes. A link can be created to a remote mailbox or process when its pid is known:</p>
<pre><code class="clj">(mbox/link (mbox/get-pid inbox))
</code></pre>
<p>The link can be removed by either of the processes in a similar manner:</p>
<pre><code class="clj">(mbox/unlink (mbox/get-pid inbox))
</code></pre>
<p>In the cases when only a “remote” message box is provided (as above), the local node in the <code>link</code> and <code>unlink</code> function calls is assumed to be the default node.</p>
<p>If the remote process terminates while the link is still in place, an error will be returned on a subsequent call to <code>receive</code>. For example, in this case, the “remote” node’s inbox pid to which we have linked is the <code>OtpMbox</code> instance stored in the <code>inbox</code> variable. The local node is our default node. Before unlinking <code>inbox</code>, if we instead call <code>(mbox/close inbox)</code> and then try to receive on the local node’s default message box, we’ll get an error. Here’s one way to handle that error:</p>
<pre><code class="clj">(match (receive)
  [:error [_ msg _]]
    (println (format "Remote pid %s has terminated."
                     (exceptions/get-pid ex)))
  data data)
</code></pre>
<h2><a href="#using-epmd" name="using-epmd"></a>Using EPMD</h2>
<p><code>epmd</code> is the Erlang Port Mapper Daemon. Distributed Erlang nodes register with <code>epmd</code> on the localhost to indicate to other nodes that they exist and can accept connections. <code>epmd</code> maintains a register of node and port number information, and when a node wishes to connect to another node, it first contacts epmd in order to find out the correct port number to connect to.</p>
<p>The basic interaction with EPMD is done through the functions in the <code>clojang.epmd</code> namespace. Under the hood (at the JInterface level), nodes wishing to contact other nodes first request information from <code>epmd</code> before a connection can be set up.</p>
<p>When manually creating connections to Erlang nodes with operations such as <code>(node/connect (self) ...)</code>, a connection is first made to <code>epmd</code> and, if the node is known, a connection is then made to the Erlang node.</p>
<p>Clojang nodes can also register themselves with <code>epmd</code> if they want other nodes in the system to be able to find and connect to them. This is done by call to <code>(epmd/publish-port ...)</code>.</p>
<p>Be aware that on some systems (such as VxWorks), a failed node will not be detected by this mechanism since the operating system does not automatically close descriptors that were left open when the node failed. If a node has failed in this way, <code>epmd</code> will prevent you from registering a new node with the old name, since it thinks that the old name is still in use. In this case, you must unregister the name explicitly, by using <code>(epmd/unpublish-port ...)</code>. This will cause <code>epmd</code> to close the connection from the far end. Note that if the name was in fact still in use by a node, the results of this operation are unpredictable. Also, doing this does not cause the local end of the connection to close, so resources may be consumed.</p>
<h2><a href="#remote-procedure-calls" name="remote-procedure-calls"></a>Remote Procedure Calls</h2>
<p>An Erlang node acting as a client to another Erlang node typically sends a request and waits for a reply. Such a request is included in a function call at a remote node and is called a remote procedure call. Remote procedure calls are supported through the <a href="http://clojang.github.io/clojang/current/clojang.rpc.html">clojang.rpc</a> namespace. The following example shows how the <code>rpc</code> protocol is used for remote procedure calls:</p>
<pre><code class="clj">(rpc/! :clojang-lfe :erlang :date)
(rpc/receive :clojang-lfe)
[2016 1 30]
</code></pre>
<h2><a href="#results" name="results"></a>Results</h2>
<h3><a href="#functions-with-return-values" name="functions-with-return-values"></a>Functions with Return Values</h3>
<p>In <code>clojang</code>, functions that return values (many of which obtain them from calls to <code>jiface</code>) often need to convert from the underlying <code>JInterface</code> custom Java types to Clojure types and or data structures. This is done whenever possible, providing as native a feel of the <code>clojang</code> API as possible.</p>
<h3><a href="#functions-with-side-effects" name="functions-with-side-effects"></a>Functions with Side-effects</h3>
<p>In Erlang, functions that do not return results sometimes return <code>true</code>, other times <code>ok</code> or <code>{ok}</code> (the latter being an Erlang tuple type). In Clojang, these are all unified under a single return value of <code>:ok</code>.</p>
<h2><a href="#errors-and-exception-handling" name="errors-and-exception-handling"></a>Errors and Exception-handling</h2>
<p>Clojang whole-heartedly adopts the Erlang ethos of dealing with errors as data. As such the only time you will see an exception in Clojang is if:</p>
<ul>
  <li>you are using code which is still under development</li>
  <li>you have discovered a bug</li>
</ul>
<p>All functions that result in an underlying Java, <code>JInterface</code>, or Clojure exception will instead return a vector of the following form:</p>
<pre><code class="clj">[:error [exception-type exception-message exception]]
</code></pre>
<p>You may use this to great advantage (clarity and conciseness) in your code with pattern matching, similarly as to how these are handled in Erlang:</p>
<pre><code class="clj">TBD
</code></pre></div></div></div></body></html>