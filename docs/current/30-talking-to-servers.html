<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Talking to Servers: LFE &amp; Clojure</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">clojang</span> <span class="project-version">0.4.0-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="20-mid-level-api.html"><div class="inner"><span>Clojang User's Guide</span></div></a></li><li class="depth-1  current"><a href="30-talking-to-servers.html"><div class="inner"><span>Talking to Servers: LFE &amp; Clojure</span></div></a></li><li class="depth-1 "><a href="31-talking-to-servers-erlang.html"><div class="inner"><span>Talking to Servers: Erlang &amp; Clojure</span></div></a></li><li class="depth-1 "><a href="32-talking-to-servers-elixir.html"><div class="inner"><span>Talking to Servers: Elixir &amp; Clojure</span></div></a></li><li class="depth-1 "><a href="40-creating-apps.html"><div class="inner"><span>Apps Tutorial</span></div></a></li><li class="depth-1 "><a href="98-other-resources.html"><div class="inner"><span>Other Resources</span></div></a></li><li class="depth-1 "><a href="99-other-versions.html"><div class="inner"><span>API Docs (All Versions)</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>clojang</span></div></div></li><li class="depth-2 branch"><a href="clojang.caller.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>caller</span></div></a></li><li class="depth-2 branch"><a href="clojang.conn.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>conn</span></div></a></li><li class="depth-2 branch"><a href="clojang.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="clojang.dev.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>dev</span></div></a></li><li class="depth-2 branch"><a href="clojang.epmd.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>epmd</span></div></a></li><li class="depth-2 branch"><a href="clojang.exceptions.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>exceptions</span></div></a></li><li class="depth-2 branch"><a href="clojang.mbox.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>mbox</span></div></a></li><li class="depth-2 branch"><a href="clojang.msg.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>msg</span></div></a></li><li class="depth-2 branch"><a href="clojang.node.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>node</span></div></a></li><li class="depth-2 branch"><a href="clojang.rpc.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>rpc</span></div></a></li><li class="depth-2"><a href="clojang.types.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>types</span></div></a></li><li class="depth-3 branch"><a href="clojang.types.constructor.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>constructor</span></div></a></li><li class="depth-3 branch"><a href="clojang.types.converter.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>converter</span></div></a></li><li class="depth-3 branch"><a href="clojang.types.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-3"><a href="clojang.types.predicate.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>predicate</span></div></a></li><li class="depth-2"><a href="clojang.util.html"><div class="inner"><span class="tree" style="top: -145px;"><span class="top" style="height: 154px;"></span><span class="bottom"></span></span><span>util</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#talking-to-servers-lfe-clojure" name="talking-to-servers-lfe-clojure"></a>Talking to Servers: LFE &amp; Clojure</h1>
<p>This tutorial covers the two-sided topic of communications between LFE and Clojure:</p>
<ul>
  <li>Clojure communicating as a client with LFE servers</li>
  <li>Simple LFE Server</li>
  <li>LFE Client Example Usage</li>
  <li>Clojure Client Example Usage</li>
  <li>Using OTP
    <ul>
      <li>LFE-side Server</li>
      <li>Clojure-side RPC</li>
    </ul>
  </li>
  <li>LFE communicating as a client with Clojure servers</li>
  <li>Simple Clojure Server</li>
  <li>LFE Client-side Usage</li>
</ul>
<h2><a href="#clojure-client-with-lfe-server" name="clojure-client-with-lfe-server"></a>Clojure Client with LFE Server</h2>
<p>Creating robust servers is the bread and butter of LFE/OTP, so we’ll start with Clojure as a client and LFE taking the role of running some servers. We’ll look at two examples:</p>
<ol>
  <li>A very simple LFE server, and</li>
  <li>An LFE <code>gen_server</code> built with OTP</li>
</ol>
<h3><a href="#a-simple-lfe-server" name="a-simple-lfe-server"></a>A Simple LFE Server</h3>
<p>Before we look at the “right way” to start thinking about long-running processes in the Erlang VM (using the infrastructure of OTP to build for reliability), we’re going to try out a highly simplified LFE server … of the “ping-pong” variety.</p>
<p>First, start up an LFE REPL by running this command in the cloned <code>clojang</code> directory:</p>
<pre><code class="bash">$ make repl
LFE Shell V7.2 (abort with ^G)
(clojang-lfe@host)&gt;
</code></pre>
<p>This will put you at an LFE prompt showing the node name and the host, indicating that you are running in “distributed” mode, able to communicate with other nodes:</p>
<pre><code class="cl">(clojang-lfe@host)&gt;
</code></pre>
<p>Paste the following into the REPL at the prompt:</p>
<pre><code class="cl">(defun ping-pong (count)
  (receive
    (`#(ping ,caller)
      (! caller 'pong) (ping-pong (+ 1 count)))
    (`#(get-count ,caller)
      (! caller count) (ping-pong count))
    (`#(stop ,caller)
      (! caller 'stopped) 'stopped)))

(defun start-server (init-state)
  (spawn
    (lambda ()
      (ping-pong init-state))))
</code></pre>
<p>Keep in mind that this is for demonstration purposes only! The simplicity of the above example may inspire you, but you’ll need more than this to run your LFE/Elixir/Erlang apps in production!</p>
<p>All we need now to turn this into a simplistic server is to spawn it:</p>
<pre><code class="cl">(clojang-lfe@host)&gt; (set ping-pong-pid (start-server 0))
&lt;0.71.0&gt;
</code></pre>
<h3><a href="#lfe-client-example-usage" name="lfe-client-example-usage"></a>LFE Client Example Usage</h3>
<p>With the LFE REPL as our implicit client, let’s send the server some messages:</p>
<pre><code class="cl">(clojang-lfe@host)&gt; (! ping-pong-pid `#(ping ,(self)))
#(ping &lt;0.68.0&gt;)
(clojang-lfe@host)&gt; (! ping-pong-pid `#(ping ,(self)))
#(ping &lt;0.68.0&gt;)
(clojang-lfe@host)&gt; (! ping-pong-pid `#(ping ,(self)))
#(ping &lt;0.68.0&gt;)
</code></pre>
<p>Since we’re using the LFE REPL as the client, we’ll need to <code>flush</code> its inbox to get the messages that our simple little server is sending to it:</p>
<pre><code class="cl">(clojang-lfe@host)&gt; (c:flush)
Shell got pong
Shell got pong
Shell got pong
ok
</code></pre>
<p>Let’s make the other call:</p>
<pre><code class="cl">(clojang-lfe@host)&gt; (! ping-pong-pid `#(get-count ,(self)))
#(get-count &lt;0.68.0&gt;)
(clojang-lfe@host)&gt; (c:flush)
Shell got 3
ok
</code></pre>
<p>We’re going to want to call this from Clojure too, so let’s register the LFE process with a name:</p>
<pre><code class="cl">(clojang-lfe@host)&gt; (register 'ping-pong ping-pong-pid)
true
</code></pre>
<h3><a href="#clojure-client-example-usage" name="clojure-client-example-usage"></a>Clojure Client Example Usage</h3>
<p>In a separate terminal window (in the Clojang top-level directory, just like the <code>make repl</code> command), start up the Clojure REPL:</p>
<pre><code class="bash">$ lein repl
nREPL server started on port 58369 on host 127.0.0.1 - nrepl://127.0.0.1:58369
REPL-y 0.3.7, nREPL 0.2.10
Clojure 1.8.0
clojang.dev=&gt;
</code></pre>
<p>The Clojang project automatically loads up a development namespace for you, <code>clojang.dev</code>, when you start the Clojure REPL, with everything you need to start talking to Erlang nodes.</p>
<p>With the <code>clojang.dev</code> REPL running, w’re ready to try out some calls to our simple LFE server:</p>
<pre><code class="clj">clojang.dev=&gt; (! :ping-pong "clojang-lfe@host" [:ping (self)])
:ok
clojang.dev=&gt; (! :ping-pong "clojang-lfe@host" [:ping (self)])
:ok
clojang.dev=&gt; (! :ping-pong "clojang-lfe@host" [:ping (self)])
:ok
clojang.dev=&gt; (receive)
:pong
clojang.dev=&gt; (receive)
:pong
clojang.dev=&gt; (receive)
:pong
clojang.dev=&gt; (! :ping-pong "clojang-lfe@host" [:get-count (self)])
:ok
clojang.dev=&gt; (receive)
6
clojang.dev=&gt; (! :ping-pong "clojang-lfe@host" [:stop (self)])
:ok
clojang.dev=&gt; (receive)
:stopped

</code></pre>
<p>Back on the LFE side, we can check to make sure that the process was indeed stopped:</p>
<pre><code class="cl">(clojang-lfe@host)&gt; (is_process_alive ping-pong-pid)
false
</code></pre>
<p>To make sure our node no longer has an open port, we can query EPMD:</p>
<pre><code class="clj">clojang.dev=&gt; (epmd/lookup-names)
[["clojang" 38581] ["clojang-lfe" 42399]]
</code></pre>
<h3><a href="#using-otp" name="using-otp"></a>Using OTP</h3>
<p>Now we’re going to look at creating an LFE server that you could put into a supervision tree and run in production: LFE with OTP.</p>
<h4><a href="#lfe-side-server" name="lfe-side-server"></a>LFE-side Server</h4>
<p>In the <code>examples</code> directory of the Clojang source code there is a module containing a variation on the classic “ping-pong” server. It’s written in LFE, but it could have been done in any BEAM (Erlang VM) language. Here’s the code:</p>
<pre><code class="cl">(defmodule ping-pong
  (behaviour gen_server)
  (export
    ;; gen_server implementation
    (start 0)
    (stop 0)
    ;; callback implementation
    (init 1)
    (handle_call 3)
    (handle_info 2)
    (terminate 2)
    (code_change 3)
    ;; server API
    (ping 0)
    (get-ping-count 0)))

;;; config functions

(defun server-name () (MODULE))
(defun callback-module () (MODULE))
(defun initial-state () 0)
(defun genserver-opts () '())
(defun register-name () `#(local ,(server-name)))
(defun unknown-command () #(error "Unknown command."))

;;; gen_server implementation

(defun start ()
  (gen_server:start (register-name)
                    (callback-module)
                    (initial-state)
                    (genserver-opts)))

(defun stop ()
  (gen_server:call (server-name) 'stop))

;;; callback implementation

(defun init (initial-state)
  `#(ok ,initial-state))

(defun handle_call
  (('ping _caller state-data)
    `#(reply pong ,(+ 1 state-data)))
  (('ping-count _caller state-data)
    `#(reply ,state-data ,state-data))
  (('stop _caller state-data)
    `#(stop shutdown ok ,state-data))
  ((_message _caller state-data)
    `#(reply ,(unknown-command) ,state-data)))

(defun handle_info
  ((`#(EXIT ,_pid normal) state-data)
   `#(noreply ,state-data))
  ((`#(EXIT ,pid ,reason) state-data)
   (io:format "Process ~p exited! (Reason: ~p)~n" `(,pid ,reason))
   `#(noreply ,state-data))
  ((_msg state-data)
   `#(noreply ,state-data)))

(defun terminate (_reason _state-data)
  'ok)

(defun code_change (_old-version state _extra)
  `#(ok ,state))

;;; our server API

(defun ping ()
  (gen_server:call (server-name) 'ping))

(defun get-ping-count ()
  (gen_server:call (server-name) 'ping-count))
</code></pre>
<p>We’re going to compile and then run that code from the LFE REPL. Then, from a Clojure REPL, we’ll talk to it.</p>
<p>From the previous example, you should already have your LFE REPL running. Let’s go ahead and compile the example:</p>
<pre><code class="cl">(clojang-lfe@host)&gt; (c "examples/ping-pong.lfe")
(#(module ping-pong))
</code></pre>
<p>Now we can start it:</p>
<pre><code class="cl">(clojang-lfe@host)&gt; (ping-pong:start)
#(ok &lt;0.45.0&gt;)
</code></pre>
<h4><a href="#clojure-side-rpc" name="clojure-side-rpc"></a>Clojure-side RPC</h4>
<p>With our LFE server running, let’s jump back over to the Clojure REPL and make some RPC calls to our LFE server by passing the module <code>:ping-pong</code> and the function name <code>:ping</code>:</p>
<pre><code class="clj">clojang.dev=&gt; (rpc/! :clojang-lfe :ping-pong :ping)
:ok
clojang.dev=&gt; (rpc/! :clojang-lfe :ping-pong :ping)
:ok
clojang.dev=&gt; (rpc/! :clojang-lfe :ping-pong :ping)
:ok
clojang.dev=&gt; (rpc/receive :clojang-lfe)
:pong
clojang.dev=&gt; (rpc/receive :clojang-lfe)
:pong
clojang.dev=&gt; (rpc/receive :clojang-lfe)
:pong
clojang.dev=&gt; (rpc/! :clojang-lfe :ping-pong :get-ping-count)
:ok
clojang.dev=&gt; (rpc/receive :clojang-lfe)
3
</code></pre>
<p>You may also use the fully qualified node name, if you wish – but you must choose one or the other, not both. If you wish to switch, you will need to close the implicit connection created first:</p>
<pre><code class="clj">clojang.dev=&gt; (rpc/close :clojang-lfe)
:ok
</code></pre>
<p>Now you can use a different node name (which will reconnect to the remote node):</p>
<pre><code class="clj">clojang.dev=&gt; (rpc/! "clojang-lfe@host" :ping-pong :ping)
:ok
clojang.dev=&gt; (rpc/receive "clojang-lfe@host")
:pong
clojang.dev=&gt; (rpc/receive "clojang-lfe@host" :ping-pong :get-ping-count)
:ok
clojang.dev=&gt; (rpc/receive "clojang-lfe@host")
4
clojang.dev=&gt; (rpc/close "clojang-lfe@host")
:ok
</code></pre>
<p>While the emphasis here is remote communications, it goes without saying that local LFE sends are also possible. Since this is a <code>gen_server</code> implementation, the proper way to do this is by calling the API we defined:</p>
<pre><code class="cl">(clojang-lfe@host)&gt; (ping-pong:ping)
pong
(clojang-lfe@host)&gt; (ping-pong:ping)
pong
(clojang-lfe@host)&gt; (ping-pong:ping)
pong
(clojang-lfe@host)&gt; (ping-pong:get-ping-count)
7
</code></pre>
<p>However, a remote LFE node would use the Erlang <code>rpc</code> module similarly to how we did from Clojure:</p>
<pre><code class="cl">(clojang-lfe@host)&gt; (rpc:cast 'clojang-lfe@host 'ping-pong 'ping '())
true
(clojang-lfe@host)&gt; (rpc:call 'clojang-lfe@host 'ping-pong 'get-ping-count '())
8
</code></pre>
<p>Note that in the <code>rpc</code> Erlang module, <code>cast</code> is used for when no result is expected and <code>call</code> is used when there is.</p>
<p>The <code>clojang.rpc</code> namespace provides <code>cast</code> and <code>call</code> as convenience functions which perform a <code>send</code> and then <code>receive</code> in the same function, emulating a blocking call:</p>
<pre><code class="clj">clojang.dev=&gt; (rpc/cast :clojang-lfe :ping-pong :ping)
:ok
clojang.dev=&gt; (rpc/call :clojang-lfe :ping-pong :get-ping-count)
9
</code></pre>
<p>You may, of course, use <code>call</code> with the remote <code>ping</code> function, since it does return a value:</p>
<pre><code class="clj">clojang.dev=&gt; (rpc/call :clojang-lfe :ping-pong :ping)
:pong
</code></pre>
<p>Our example use of RPC has focused strictly on the module we compiled (and its contained functions). Regardless, the same usage applies to all Erlang modules and functions on the remote node, however:</p>
<pre><code class="clj">clojang.dev=&gt; (rpc/call :clojang-lfe :erlang :date)
[2017 1 17]
clojang.dev=&gt; (rpc/call :clojang-lfe :erlang :abs [-1])
1
</code></pre>
<p>Let’s cleanup:</p>
<pre><code class="clj">clojang.dev=&gt; (rpc/close :clojang-lfe)
:ok
</code></pre>
<h2><a href="#lfe-client-with-clojure-server" name="lfe-client-with-clojure-server"></a>LFE Client with Clojure Server</h2>
<p>Just as with the LFE server examples above, we’ll write a simple Clojure server first, communicate with it via an LFE client, and then write a bit more robust example Clojure server.</p>
<h3><a href="#simple-clojure-server" name="simple-clojure-server"></a>Simple Clojure Server</h3>
<p>With the core.match library for Clojure, we are able to get remarkably close to the little server we wrote in LFE above:</p>
<pre><code class="clojure">(require '[clojure.core.match :refer [match]])

(defn ping-pong
  []
  (let [init-state 0]
    (loop [png-count init-state]
      (match (receive)
        [:ping caller]
          (do (! caller :pong)
            (recur (inc png-count)))
        [:get-ping-count caller]
          (do (! caller png-count)
            (recur png-count))
        [:stop caller]
          (do (! caller :stopping)
              :stopped)))))
</code></pre>
<p>Not only are both LFE and Clojure Lisps (though LFE is a Lisp-2 … and then some … while Clojure is a Lisp-1), but with the addition of core.match to the Clojure code, we can have a very similar developer experience in both languages. How nice!</p>
<p>Let’s paste this server into the Clojure REPL and then run it:</p>
<pre><code class="clojure">(ping-pong)
</code></pre>
<h3><a href="#lfe-client-side-usage" name="lfe-client-side-usage"></a>LFE Client-side Usage</h3>
<p>Now let’s head over to an LFE REPL and talk to the Clojure server:</p>
<pre><code class="cl">(clojang-lfe@host)&gt; (! #(default clojang@host) `#(ping ,(self)))
#(ping &lt;0.34.0&gt;)
(clojang-lfe@host)&gt; (! #(default clojang@host) `#(ping ,(self)))
#(ping &lt;0.34.0&gt;)
(clojang-lfe@host)&gt; (! #(default clojang@host) `#(ping ,(self)))
#(ping &lt;0.34.0&gt;)
(clojang-lfe@host)&gt; (c:flush)
Shell got pong
Shell got pong
Shell got pong
ok
(clojang-lfe@host)&gt; (! #(default clojang@host) `#(get-ping-count ,(self)))
#(get-count &lt;0.34.0&gt;)
(clojang-lfe@host)&gt; (c:flush)
Shell got 3
ok
</code></pre>
<p>Once we’re done, we can ask the server to stop from LFE:</p>
<pre><code class="cl">(clojang-lfe@host)&gt; (! #(default clojang@host) `#(stop ,(self)))
#(stop &lt;0.34.0&gt;)
(clojang-lfe@host)&gt; (c:flush)
Shell got stopping
</code></pre>
<p>Back in the Clojure REPL you should now see:</p>
<pre><code class="clojure">:stopped
</code></pre>
<h3><a href="#clojang-otp" name="clojang-otp"></a>Clojang OTP</h3>
<h4><a href="#clojure-side" name="clojure-side"></a>Clojure-side <code>gen-server</code></h4>
<p>TBD</p>
<h4><a href="#lfe-side-rpc" name="lfe-side-rpc"></a>LFE-side RPC</h4>
<p>TBD</p></div></div></div></body></html>